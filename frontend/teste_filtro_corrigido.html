<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teste: L√≥gica de Filtro Corrigida</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { padding: 20px; background: #f8f9fa; }
        .test-container { max-width: 1200px; margin: 0 auto; }
        .success { color: #059669; font-weight: bold; }
        .error { color: #DC2626; font-weight: bold; }
        .warning { color: #D97706; font-weight: bold; }
        .info { color: #2563EB; font-weight: bold; }
        .test-form { background: white; border-radius: 8px; padding: 20px; margin: 20px 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .card-status { padding: 10px; margin: 10px 0; border-radius: 5px; }
        .card-success { background: #d1fae5; border: 1px solid #10b981; }
        .card-error { background: #fee2e2; border: 1px solid #ef4444; }
        .card-warning { background: #fef3c7; border: 1px solid #f59e0b; }
        .data-table { width: 100%; border-collapse: collapse; margin: 10px 0; }
        .data-table th, .data-table td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        .data-table th { background-color: #f2f2f2; }
        .overdue { background-color: #fee2e2; }
        .upcoming { background-color: #d1fae5; }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>üîß Teste: L√≥gica de Filtro Corrigida</h1>
        <p>Verificando se a l√≥gica de filtro foi corrigida para separar corretamente contas vencidas e pr√≥ximas.</p>
        
        <div class="alert alert-info">
            <h6>üéØ Problema Corrigido:</h6>
            <ul>
                <li><strong>Problema:</strong> Contas com pagamento futuro estavam sendo carregadas nas contas vencidas</li>
                <li><strong>Solu√ß√£o:</strong> L√≥gica de filtro corrigida para separar corretamente</li>
                <li><strong>Resultado:</strong> Contas futuras agora aparecem apenas no card de pr√≥ximas</li>
            </ul>
        </div>
        
        <div class="test-form">
            <h4>üîç Verifica√ß√£o da L√≥gica de Filtro</h4>
            
            <div class="row">
                <div class="col-md-6">
                    <h6>üìÖ Contas Vencidas</h6>
                    <div id="overdueStatus">
                        <div class="card-status card-warning">
                            <strong>Filtro:</strong> <span id="overdueFilterStatus">üîÑ Verificando...</span>
                        </div>
                    </div>
                </div>
                
                <div class="col-md-6">
                    <h6>üìÖ Contas Pr√≥ximas</h6>
                    <div id="upcomingStatus">
                        <div class="card-status card-warning">
                            <strong>Filtro:</strong> <span id="upcomingFilterStatus">üîÑ Verificando...</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="mt-4">
                <h6>üìä Dados de Teste:</h6>
                <div id="testData" style="font-family: monospace; font-size: 12px; max-height: 300px; overflow-y: auto; background: #f8f9fa; padding: 15px; border-radius: 5px;">
                    Aguardando carregamento...
                </div>
            </div>
            
            <div class="mt-4">
                <h6>üìã Resultado da Classifica√ß√£o:</h6>
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Cliente</th>
                            <th>Valor</th>
                            <th>Vencimento</th>
                            <th>Classifica√ß√£o</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="classificationTable">
                        <tr><td colspan="5">Aguardando classifica√ß√£o...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>
        
        <div class="row">
            <div class="col-md-6">
                <div class="alert alert-info">
                    <h6>üìä Status Geral:</h6>
                    <div id="generalStatus">üîÑ Verificando...</div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="alert alert-info">
                    <h6>üéØ Resultado Final:</h6>
                    <div id="finalResult">üîÑ Verificando...</div>
                </div>
            </div>
        </div>
        
        <div class="mt-4">
            <button class="btn btn-primary" onclick="testarFiltroCorrigido()">
                üßÆ Testar Filtro Corrigido
            </button>
            <button class="btn btn-success" onclick="abrirDashboard()">
                üìä Abrir Dashboard
            </button>
            <button class="btn btn-warning" onclick="limparTeste()">
                üßπ Limpar Teste
            </button>
        </div>
        
        <div class="mt-4">
            <h5>üéØ L√≥gica Corrigida:</h5>
            <div class="alert alert-success">
                <ul>
                    <li><strong>Contas Vencidas:</strong> vencimento < hoje AND status != 'pago'</li>
                    <li><strong>Contas Pr√≥ximas:</strong> hoje <= vencimento <= (hoje + 30 dias) AND status != 'pago'</li>
                    <li><strong>Sem Vencimento:</strong> N√£o aparecem em nenhum card</li>
                    <li><strong>Separa√ß√£o:</strong> Mesma conta n√£o pode aparecer em ambos os cards</li>
                </ul>
            </div>
        </div>
    </div>

    <script src="js/api.js"></script>
    <script src="js/app.js?v=3.1"></script>
    
    <script>
        let testData = [];
        
        function adicionarDados(mensagem) {
            testData.push(mensagem);
            const dataDiv = document.getElementById('testData');
            dataDiv.innerHTML = testData.slice(-20).join('<br>');
            dataDiv.scrollTop = dataDiv.scrollHeight;
        }
        
        function atualizarStatus(cardId, status, tipo = 'warning') {
            const element = document.getElementById(cardId);
            if (element) {
                element.textContent = status;
                element.className = `card-status card-${tipo}`;
            }
        }
        
        function testarFiltroCorrigido() {
            console.log('üîß === TESTE DE FILTRO CORRIGIDO ===');
            adicionarDados('üîß Iniciando teste de filtro corrigido...');
            
            try {
                // Criar dados de teste com diferentes cen√°rios
                const today = new Date();
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);
                const tomorrow = new Date(today);
                tomorrow.setDate(tomorrow.getDate() + 1);
                const nextWeek = new Date(today);
                nextWeek.setDate(nextWeek.getDate() + 7);
                const nextMonth = new Date(today);
                nextMonth.setDate(nextMonth.getDate() + 35);
                
                const testSales = [
                    {
                        id: 1,
                        cliente: 'Cliente Vencido 1',
                        valor: 1000.00,
                        vencimento: yesterday.toISOString().split('T')[0],
                        status: 'Pendente'
                    },
                    {
                        id: 2,
                        cliente: 'Cliente Vencido 2',
                        valor: 2000.00,
                        vencimento: yesterday.toISOString().split('T')[0],
                        status: 'Pendente'
                    },
                    {
                        id: 3,
                        cliente: 'Cliente Pr√≥ximo 1',
                        valor: 1500.00,
                        vencimento: tomorrow.toISOString().split('T')[0],
                        status: 'Pendente'
                    },
                    {
                        id: 4,
                        cliente: 'Cliente Pr√≥ximo 2',
                        valor: 2500.00,
                        vencimento: nextWeek.toISOString().split('T')[0],
                        status: 'Pendente'
                    },
                    {
                        id: 5,
                        cliente: 'Cliente Distante',
                        valor: 3000.00,
                        vencimento: nextMonth.toISOString().split('T')[0],
                        status: 'Pendente'
                    },
                    {
                        id: 6,
                        cliente: 'Cliente Pago',
                        valor: 500.00,
                        vencimento: yesterday.toISOString().split('T')[0],
                        status: 'Pago'
                    },
                    {
                        id: 7,
                        cliente: 'Cliente Sem Vencimento',
                        valor: 800.00,
                        vencimento: null,
                        status: 'Pendente'
                    }
                ];
                
                adicionarDados('üìä Dados de teste criados...');
                
                // Aplicar l√≥gica de filtro corrigida
                const todayReset = new Date();
                todayReset.setHours(0, 0, 0, 0);
                
                const thirtyDaysFromNow = new Date();
                thirtyDaysFromNow.setDate(thirtyDaysFromNow.getDate() + 30);
                thirtyDaysFromNow.setHours(23, 59, 59, 999);
                
                // Filtrar vendas vencidas
                const overdueSales = testSales.filter(sale => {
                    if (sale.vencimento) {
                        const dueDateObj = new Date(sale.vencimento);
                        dueDateObj.setHours(0, 0, 0, 0);
                        return dueDateObj < todayReset && sale.status !== 'pago' && sale.status !== 'paid' && sale.status !== 'Pago';
                    }
                    return false;
                });
                
                // Filtrar vendas pr√≥ximas
                const upcomingSales = testSales.filter(sale => {
                    if (sale.vencimento) {
                        const dueDateObj = new Date(sale.vencimento);
                        dueDateObj.setHours(0, 0, 0, 0);
                        return dueDateObj >= todayReset && dueDateObj <= thirtyDaysFromNow && sale.status !== 'pago' && sale.status !== 'paid' && sale.status !== 'Pago';
                    }
                    return false;
                });
                
                adicionarDados(`üìÖ Vendas vencidas encontradas: ${overdueSales.length}`);
                adicionarDados(`üìÖ Vendas pr√≥ximas encontradas: ${upcomingSales.length}`);
                
                // Verificar se a l√≥gica est√° correta
                let overdueCorrect = true;
                let upcomingCorrect = true;
                let noOverlap = true;
                
                // Verificar vendas vencidas
                overdueSales.forEach(sale => {
                    const dueDate = new Date(sale.vencimento);
                    dueDate.setHours(0, 0, 0, 0);
                    if (dueDate >= todayReset) {
                        overdueCorrect = false;
                        adicionarDados(`‚ùå Venda ${sale.id} classificada como vencida mas vence no futuro`);
                    }
                });
                
                // Verificar vendas pr√≥ximas
                upcomingSales.forEach(sale => {
                    const dueDate = new Date(sale.vencimento);
                    dueDate.setHours(0, 0, 0, 0);
                    if (dueDate < todayReset || dueDate > thirtyDaysFromNow) {
                        upcomingCorrect = false;
                        adicionarDados(`‚ùå Venda ${sale.id} classificada como pr√≥xima mas est√° fora do per√≠odo`);
                    }
                });
                
                // Verificar sobreposi√ß√£o
                const overdueIds = overdueSales.map(s => s.id);
                const upcomingIds = upcomingSales.map(s => s.id);
                const overlap = overdueIds.filter(id => upcomingIds.includes(id));
                
                if (overlap.length > 0) {
                    noOverlap = false;
                    adicionarDados(`‚ùå Sobreposi√ß√£o encontrada: vendas ${overlap.join(', ')}`);
                }
                
                // Atualizar status
                if (overdueCorrect) {
                    atualizarStatus('overdueFilterStatus', '‚úÖ Filtro vencidas correto', 'success');
                } else {
                    atualizarStatus('overdueFilterStatus', '‚ùå Filtro vencidas incorreto', 'error');
                }
                
                if (upcomingCorrect) {
                    atualizarStatus('upcomingFilterStatus', '‚úÖ Filtro pr√≥ximas correto', 'success');
                } else {
                    atualizarStatus('upcomingFilterStatus', '‚ùå Filtro pr√≥ximas incorreto', 'error');
                }
                
                // Atualizar tabela de classifica√ß√£o
                const tableBody = document.getElementById('classificationTable');
                tableBody.innerHTML = '';
                
                testSales.forEach(sale => {
                    const row = document.createElement('tr');
                    const dueDate = sale.vencimento ? new Date(sale.vencimento).toISOString().split('T')[0] : 'N/A';
                    const classification = overdueSales.find(s => s.id === sale.id) ? 'Vencida' : 
                                        upcomingSales.find(s => s.id === sale.id) ? 'Pr√≥xima' : 'N√£o Classificada';
                    const rowClass = classification === 'Vencida' ? 'overdue' : 
                                   classification === 'Pr√≥xima' ? 'upcoming' : '';
                    
                    row.className = rowClass;
                    row.innerHTML = `
                        <td>${sale.cliente}</td>
                        <td>R$ ${sale.valor.toFixed(2)}</td>
                        <td>${dueDate}</td>
                        <td>${classification}</td>
                        <td>${sale.status}</td>
                    `;
                    tableBody.appendChild(row);
                });
                
                // Atualizar status geral
                const allCorrect = overdueCorrect && upcomingCorrect && noOverlap;
                
                document.getElementById('generalStatus').innerHTML = `
                    <div class="${allCorrect ? 'success' : 'error'}">${allCorrect ? '‚úÖ' : '‚ùå'} Teste conclu√≠do</div>
                    <div><strong>Vencidas corretas:</strong> ${overdueCorrect ? '‚úÖ' : '‚ùå'}</div>
                    <div><strong>Pr√≥ximas corretas:</strong> ${upcomingCorrect ? '‚úÖ' : '‚ùå'}</div>
                    <div><strong>Sem sobreposi√ß√£o:</strong> ${noOverlap ? '‚úÖ' : '‚ùå'}</div>
                `;
                
                if (allCorrect) {
                    document.getElementById('finalResult').innerHTML = `
                        <div class="success">üéâ FILTRO CORRIGIDO COM SUCESSO!</div>
                        <div><strong>Status:</strong> L√≥gica funcionando perfeitamente</div>
                        <div><strong>Pr√≥ximo passo:</strong> Testar no dashboard real</div>
                    `;
                    adicionarDados('üéâ Filtro corrigido com sucesso!');
                } else {
                    document.getElementById('finalResult').innerHTML = `
                        <div class="error">‚ö†Ô∏è PROBLEMAS NO FILTRO</div>
                        <div><strong>Status:</strong> Necess√°rio mais corre√ß√µes</div>
                        <div><strong>Problemas:</strong> ${[!overdueCorrect, !upcomingCorrect, !noOverlap].filter(Boolean).length}</div>
                    `;
                    adicionarDados('‚ö†Ô∏è Problemas no filtro detectados');
                }
                
                adicionarDados('‚úÖ Teste de filtro conclu√≠do');
                
            } catch (error) {
                console.error('‚ùå Erro no teste de filtro:', error);
                adicionarDados(`‚ùå Erro no teste: ${error.message}`);
                
                document.getElementById('generalStatus').innerHTML = `
                    <div class="error">‚ùå Erro no teste</div>
                    <div><strong>Erro:</strong> ${error.message}</div>
                `;
            }
        }
        
        function limparTeste() {
            testData = [];
            document.getElementById('testData').innerHTML = 'Aguardando carregamento...';
            document.getElementById('classificationTable').innerHTML = '<tr><td colspan="5">Aguardando classifica√ß√£o...</td></tr>';
            
            // Resetar status dos cards
            const statusElements = [
                'overdueFilterStatus', 'upcomingFilterStatus'
            ];
            
            statusElements.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = 'üîÑ Verificando...';
                    element.className = 'card-status card-warning';
                }
            });
            
            document.getElementById('generalStatus').innerHTML = '<div>üîÑ Teste limpo</div>';
            document.getElementById('finalResult').innerHTML = '<div>üîÑ Teste limpo</div>';
        }
        
        function abrirDashboard() {
            window.open('index.html', '_blank');
        }
        
        // Configurar eventos
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ P√°gina carregada, iniciando teste de filtro...');
            adicionarDados('üöÄ P√°gina carregada, iniciando teste de filtro...');
            
            // Executar teste autom√°tico ap√≥s 2 segundos
            setTimeout(() => {
                testarFiltroCorrigido();
            }, 2000);
        });
    </script>
</body>
</html> 